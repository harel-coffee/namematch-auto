---
title: "Name Match Report"
output: pdf_document
params:
  stats_file: "~/name_match_2.0/output_temp/stats.yaml"
  output_dir: "~/name_match_2.0/output_temp"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE, 
  warning = FALSE)

library(reticulate)

stats_file = params$stats_file
```

```{r libraries, include = FALSE}
library(data.table)
library(tidyverse)
library(yaml)
```

```{python load_stats, include = FALSE}
import yaml
py_stats = yaml.load(open(r.stats_file, 'r'), Loader=yaml.FullLoader)
```

```{r load, include = FALSE}

stats = py$py_stats

ml_path = paste(params$output_dir, "must_links.csv", sep = "/")
up_path = paste(params$output_dir, "uncovered_pairs.csv", sep = "/")
an_path = paste(params$output_dir, "all_names_with_clusterid.csv", sep = "/")

ml = fread(ml_path)
an = fread(an_path)

if ('n_uncovered_pairs' %in% names(stats)) {
  show_blocking  = TRUE
  up = fread(up_path)
} else {
  show_blocking  = FALSE
}


```

```{r resources, include = FALSE}
resources_df = data.frame(
    runtime = c(stats$runtime__main__process_input_data, 
                stats$runtime__main__block,
                stats$runtime__main__generate_data_rows,
                stats$runtime__main__fit_model,
                stats$runtime__main__predict,
                stats$runtime__main__cluster),
    ram = c(stats$ram__main__process_input_data, 
                stats$ram__main__block,
                stats$ram__main__generate_data_rows,
                stats$ram__main__fit_model,
                stats$ram__main__predict,
                stats$ram__main__cluster))
rownames(resources_df) = c(
                "Processing input", 
                "Blocking", 
                'Generating data rows', 
                'Fitting model', 
                'Predicting', 
                'Clustering')
```



# Meta Data

* Start: `r strsplit(stats$start, split = "\\.")[[1]][1]`
* End: `r strsplit(stats$end, split = "\\.")[[1]][1]`
* Type: `r stats$run_type`

# Resources

```{r resources_table, echo = FALSE, results = "asis"}
knitr::kable(
  resources_df,
  row.names = TRUE,
  col.names = c("Runtime", "RAM"))
```

# Counts

* Input data rows: `r stats$n_an`
* Valid input data rows: `r stats$n_valid_an`
* Candidate pairs: `r stats$n_cand_pairs`
* Data rows: `r stats$n_data_rows`
* Potential edges: `r stats$n_potential_edges`
* Clusters: `r stats$n_clusters`


```{r, include = FALSE}

# weird hacky way of making a histogram out of pre-binned numbers

mids = seq(0.05, 0.95, by = 0.1)
breaks = seq(0, 1, by = 0.1)

expand_df = function(ns, label = "") {

  ns[is.na(ns)] = 0

  df = data.frame("vals" = mids, "n" = round(ns * 1000))
  
  if (sum(ns) == 0) {
    return(NULL)
  } else {
    return(data.frame("x" = rep(df$val, df$n), "type" = label))
  }
  
}

```


\newpage


```{r blockheaders, results = "asis", echo = FALSE, eval = show_blocking}
cat('# Blocking')
cat('\n\n')
cat('**Pair completeness:**')
```

```{r format_pc, include = FALSE, eval = show_blocking}
pc = data.frame("v1" = c(stats$pc_eq_cos, stats$pc_eq_cosed),
                "v2" = c(stats$pc_neq_cos, stats$pc_neq_cosed))
rownames(pc) = c("Cosine Distance", "Cosine and Edit Distance")
```

```{r pc_table, echo = FALSE, results = "asis", eval = show_blocking}
knitr::kable(
  pc,
  col.names = c("Including Identical Pairs", "Excluding Identical Pairs"),
  digits = 3)
```

```{r up, results = "asis", echo = FALSE, eval = show_blocking}
cat(paste0('Number of uncovered pairs: ', stats$n_uncovered_pairs, ' (', 
           round(stats$n_uncovered_pairs / stats$n_true_blockstring_pairs, 3), '%)'))
```


```{r cos_dist_plot, echo = FALSE, fig.width = 7.5, fig.height = 4, eval = show_blocking}


df = rbindlist(list(
  expand_df(stats$up_cosine_distribution, "Uncovered"),
  expand_df(stats$tp_cosine_distribution, "All")))

cat("\n")

ggplot(data = df,
       aes(x = x, fill = type)) +
  geom_histogram(breaks = breaks, position = "dodge") +
  scale_x_continuous(breaks = breaks) +
  scale_y_continuous(breaks = seq(0, 1000, length.out = 11), labels = as.character(breaks)) +
  labs(title = "Cosine similarity of true pairs",
       x = "Cosine Similarity",
       y = "Proportion",
       fill = "") +
  theme_bw() +
  theme(text = element_text(family = "serif"))

```



\newpage

```{r format_model_stats, include = FALSE}

if ('model_stats__match' %in% names(stats)) {
  show_modeling  = TRUE
} else {
  show_modeling  = FALSE
}

ms = stats$model_stats__match
model_names = names(ms)

stat_names = c("baserate", "precision", "recall", "fscore", "auc")

stat_df_list = list()
for (model_name in model_names) {
  stat_df = data.table("name" = stat_names)
  stat_df[, all := sapply(name, function(x) { ms[[model_name]]$`all pairs`[[x]] })]
  stat_df[, non := sapply(name, function(x) { ms[[model_name]]$`non exactmatch pairs`[[x]] })]
  stat_df[, model_name := model_name]
  stat_df_list[[model_name]] = stat_df
}
stat_df = rbindlist(stat_df_list)
```

```{r feature_loop, results = "asis", echo = FALSE, fig.width = 7.5, fig.height = 4, eval = show_modeling}

cat('# Modeling')

f = stats$feature_info__match
thresh_dict = stats$model_thresholds__match

for (model in names(f)) {
  
  cat("\n")

  thresh = thresh_dict[[model]]
  this_stat_df = stat_df[model_name == model]
  
  string = paste(
    "## ",
    paste("`", model, "`", sep = ""),
    paste("\n\nThreshold: `", thresh, "`\n\n", sep = ""),
    sep = ""
  )
  
  cat(string)

  print(knitr::kable(this_stat_df[, -'model_name'], digits = 4, col.names = c("Statistic", "All Pairs", "Non Exact Match")))

  cat("\n\n")
  
  vars = tstrsplit(f[[model]][["retained"]], "var_")[[2]]
  importance = f[[model]][["imp"]]
  
  dt = data.table("vars" = vars, "imp" = importance)
  dt = dt[order(-imp)]
  
  print(knitr::kable(dt[1:5, ], col.names = c("Variable", "Importance"), digits = 4))
  
  string = paste(
    "\n\n**Dropped features:**\n\n",
    paste(tstrsplit(f[[model]][["dropped"]], "var_")[[2]], collapse = ", "),
    "\n\n",
    sep = ""
  )
  
  cat(string)

  df = rbindlist(list(
    expand_df(ms[[model]]$`all pairs`$phat_distribution_0s, "All Pairs"),
    expand_df(ms[[model]]$`exactmatch pairs`$phat_distribution_0s, "Identical"),
    expand_df(ms[[model]]$`non exactmatch pairs`$phat_distribution_0s, "Non Identical")))

  if (nrow(df) > 0) {

    cat("\n\n")

    print(ggplot(data = df,
           aes(x = x, fill = type)) +
      geom_histogram(breaks = breaks, position = "dodge") +
      scale_x_continuous(breaks = breaks) +
      scale_y_continuous(breaks = seq(0, 1000, length.out = 11), labels = as.character(breaks)) +
      labs(title = "p-hats of labeled non matches",
           x = "phat",
           y = "Proportion",
           fill = "") +
      theme_bw() +
      theme(text = element_text(family = "serif")))
    }

  cat("\n")

  df = rbindlist(list(
    expand_df(ms[[model]]$`all pairs`$phat_distribution_1s, "All Pairs"),
    expand_df(ms[[model]]$`exactmatch pairs`$phat_distribution_1s, "Identical"),
    expand_df(ms[[model]]$`non exactmatch pairs`$phat_distribution_1s, "Non Identical")))

  if (nrow(df) > 0) {

    print(ggplot(data = df,
           aes(x = x, fill = type)) +
      geom_histogram(breaks = breaks, position = "dodge") +
      scale_x_continuous(breaks = breaks) +
      scale_y_continuous(breaks = seq(0, 1000, length.out = 11), labels = as.character(breaks)) +
      labs(title = "p-hats of labeled matches",
           x = "phat",
           y = "Proportion",
           fill = "") +
      theme_bw() +
      theme(text = element_text(family = "serif")))
  } 

  cat('\n')
  
}
```


\newpage

# Clustering

* Number of initial clusters: `r stats$n_initial_clusters`
* Number of invalid edges: `r stats$n_invalid_edges`
* Number of invalid clusters: `r stats$n_invalid_clusters`
* Number of merges: `r stats$n_merges`
* Number of clusters: `r stats$n_clusters`
* Number of singleton clusters: `r stats$n_singleton_clusters`

**Ten largest clusters:**

```{r largestclusters, include = FALSE}

# in the future include within-cluster stats
# eg: how many distinct first names?
# eg: are the records all of the same type?
# potentially outsource this to a "cluster_evaluation" function in clustering.py
# as i supsect it will be easier / faster in pandas

largestclusters = table(an$cluster_id) %>%
  sort(decreasing = TRUE) %>%
  data.table() %>%
  head(10)
largestclusters$rank = 1:10
```

```{r mc_table, echo = FALSE, results = "asis"}
knitr::kable(largestclusters[, .(rank, V1, N)], col.names = c("Rank", "Cluster ID", "Number of Records"))
```

\newpage

```{r load_data, include = FALSE, eval = show_blocking}

# get covered pair status from tp
up[, status := "Uncovered"]
pairs = merge(ml, up[, c('blockstring_1', 'blockstring_2', 'status')], 
              by = c('blockstring_1', 'blockstring_2'), all.x = T)
pairs[is.na(status), status := "Covered"]
pairs = pairs[, .(record_id_1, record_id_2, status)]

# get information from an
pairs = merge(an, pairs, by.x = "record_id", by.y = "record_id_1")
pairs = merge(an, pairs, by.x = "record_id", by.y = "record_id_2", suffix = c("_1", "_2"))
```

```{r evaluate_cat, include = FALSE, eval = show_blocking}

evaluate_cat = function(v) {
    
  v1 = paste(v, "1", sep = "_")
  v2 = paste(v, "2", sep = "_")
  
  output = list()
  output$n_record_pairs = nrow(pairs)
  
  # subset to the rows where the variables match
  p = pairs[, same_v := (get(v1) == get(v2))]
  output$diff_v = nrow(p[same_v == FALSE, ])
  p = p[same_v == TRUE, ]
  if (nrow(p) == 0) {
    output$no_pairs = TRUE
    return(output)
  }
  
  output$no_pairs = FALSE
  
  # make the table
  t = data.table(table(p[, get(v1)], p[, status]))
  t = dcast(t, V1 ~ V2)
  if (ncol(t) == 3) {
   t[, "Covered Rate" := (Covered / (Covered + Uncovered))] 
  }
  
  output$table = t
  
  return(output)
  
}

```

```{r error_loop, results = "asis", echo = FALSE, eval = show_blocking}

cat('# Error Rates')

for (v in stats$categorical_variables) {

  res = evaluate_cat(v)
  if (res$no_pairs) {
    next
  }
  
  string = paste(
    "## ",
    paste("`", v, "`", sep = ""),
    "\n\n",
    as.character(res$diff_v),
    " of ",
    as.character(res$n_record_pairs),
    " true record pairs were excluded because they had different values for ",
    paste("`", v, "`", sep = ""),
    ".\n\n",
    sep = ""
  )
  
  cat("\n")
  cat(string)
  
  print(knitr::kable(res$table))
  
  cat("\n")
  
}


